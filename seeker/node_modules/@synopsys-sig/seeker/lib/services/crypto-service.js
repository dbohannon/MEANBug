"use strict";function e(){function e(e,t){void 0===e.__sk_inputValue&&(e.__sk_inputValue=""),e.__sk_inputValue+=e.__sk_inputValue.length<100?t[0].substring(0,Math.min(t[0].length,100-e.__sk_inputValue.length)):"",r.trace("Intercept cipher update - input: %s",t[0])}function t(e){let t={algorithm:e.__sk_algorithm,keyVal:e.__sk_keyVal,input:e.__sk_inputValue};module.exports.emit("cipher",t)}function i(e){module.exports.emit("algorithm",e.__sk_algorithm)}function n(e){return"string"==typeof e?Buffer.from(e,"utf8"):e}function o(){const e={__sk_doAfter:function(e,t,i){return t.__sk_algorithm=i[0],t.__sk_keyVal=n(i[1]),r.debug("Intercept createCipher - cipher: %s",t.__sk_algorithm),t}};l.services.instrumentation.register({moduleId:"crypto",methodNames:"createCipheriv",type:"instance",callbacks:e}),l.services.instrumentation.register({wrapperName:"__sk_inst_functions",methodNames:"cryptoCreateCipher",type:"instance",callbacks:e})}function s(){l.services.instrumentation.register({moduleId:"crypto",methodNames:["createHash","createHmac"],type:"instance",callbacks:{__sk_doAfter:function(e,t,i){return t.__sk_algorithm=i[0],r.debug("Intercept createHash - Hash: %s",t.__sk_algorithm),t}}})}function a(){l.services.instrumentation.register({moduleId:"crypto",wrapperName:"Cipher",methodNames:"update",type:"prototype",callbacks:{__sk_doBefore:function(t,r){e(t,r)}}})}function c(){l.services.instrumentation.register({moduleId:"crypto",wrapperName:"Cipheriv",methodNames:"update",type:"prototype",callbacks:{__sk_doBefore:function(t,r){e(t,r)}}})}function u(){l.services.instrumentation.register({moduleId:"crypto",wrapperName:"Cipher",methodNames:["final","_flush"],type:"prototype",callbacks:{__sk_doBefore:function(e){t(e)}}})}function _(){l.services.instrumentation.register({moduleId:"crypto",wrapperName:"Cipheriv",methodNames:["final","_flush"],type:"prototype",callbacks:{__sk_doBefore:function(e){t(e)}}})}function p(){["Hash","Hmac"].forEach(e=>{l.services.instrumentation.register({moduleId:"crypto",wrapperName:e,methodNames:["digest"],type:"prototype",callbacks:{__sk_doBefore:function(e){i(e)}}})})}function m(){["Hash","Hmac"].forEach(e=>{l.services.instrumentation.register({moduleId:"crypto",wrapperName:e,methodNames:["update"],type:"prototype",callbacks:{__sk_doBefore:function(e,t){module.exports.emit("update",{input:t[0],algorithm:e.__sk_algorithm})},__sk_doAfter:function(e,t){return t}}})})}let l;this.init=function(e){l=e,o(),m(),a(),c(),u(),_(),s(),p()}}const t=require("util"),r=require("../util/logger");t.inherits(e,require("./_AbstractService")),module.exports=new e;